#version 410 // -*- c++ -*-
#include <g3dmath.glsl>
#include <Texture/Texture.glsl>
#include "Surfel.glsl"
#include "Sphere.glsl"

// Input arguments from the C++ program
uniform mat4x3 cameraToWorldMatrix;

uniform TextureCube	environmentMap;

uniform float tanHalfFieldOfViewY;
uniform float projectionMatrix22, projectionMatrix23;

// Output to the App::m_framebuffer
out Color3 pixelColor;

const int NUM_SPHERES = 2;
Sphere spheres[NUM_SPHERES];

void fillScene()
{
	spheres[0].center = Point3(1.0f, 0.0f, -1.0f);
	spheres[0].radius = 0.8f;
	spheres[0].material.color = Color3(0.5f, 0.0f, 0.0f);

	spheres[1].center = Point3(-1.0f, 0.0f, -1.0f);
	spheres[1].radius = 0.6f;
	spheres[1].material.color = Color3(0.0f, 0.5f, 0.0f);
}

float sceneDistance(Point3 X)
{
	float minDistance = 10000000.0f;

	for (int i = 0; i < NUM_SPHERES; i++) {
		float currDistance = length(X - spheres[i].center) - spheres[i].radius;
		
		if (currDistance < minDistance) {
			minDistance = currDistance;
		}
	}

	return minDistance;
}



float sceneDistance(Point3 X, inout Material closestMaterial)
{
	float minDistance = 10000000.0f;

	for (int i = 0; i < NUM_SPHERES; i++) {
		float currDistance = length(X - spheres[i].center) - spheres[i].radius;
		
		if (currDistance < minDistance) {
			minDistance = currDistance;
			closestMaterial = spheres[i].material;
		}
	}

	return minDistance;
}



Vector3 fastNormal(Point3 X)
{
	const float e = 1e-4f;
	float d = sceneDistance(X);

	return normalize(Vector3(
			sceneDistance(X + Vector3(e, 0, 0)),
			sceneDistance(X + Vector3(0, e, 0)),
			sceneDistance(X + Vector3(0, 0, e))) - Vector3(d, d, d));
}



Radiance3 lambertianBrdf(Material material)
{
	return Radiance3(material.color / 3.14f);
}



Radiance3 shadeSurfel(Surfel surfel)
{
	vec3 sunRadiance = vec3(1.0f);
	vec3 sunDirection = normalize(vec3(-1.0f, -1.0f, -1.0f));

	vec3 direct = lambertianBrdf(surfel.material) * sunRadiance * dot(-sunDirection, surfel.normal);
	vec3 ambient = 0.3f * surfel.material.color;
	return direct + ambient;
}



Radiance3 traceRay(Point3 P, Vector3 w) {
	const float maxDistance   = 1e10;
	const int   maxIterations = 100;
	const float closeEnough   = 1e-2;

	float t = 0;
	Surfel closestSurfel;

	for (int i = 0; i < maxIterations; ++i) {
		float dt = sceneDistance(P + w * t, closestSurfel.material);
		t += dt;

		if (dt < closeEnough) {
			closestSurfel.position = P + w * t;
			closestSurfel.normal = fastNormal(closestSurfel.position);

			return shadeSurfel(closestSurfel);
		}
	}
	return sampleTexture(environmentMap, w).rgb;
}



void main()
{
	fillScene();

	// Generate an eye ray in camera space, and then transform to world space

	// Primary ray origin	
	Point3 P  = cameraToWorldMatrix[3];

	// Primary ray direction
	Vector3 w = Matrix3(cameraToWorldMatrix) * 
		normalize(Vector3((gl_FragCoord.xy - g3d_FragCoordExtent / 2.0) * Vector2(1, -1),
						  g3d_FragCoordExtent.y / ( -2.0 * tanHalfFieldOfViewY)));

	float maxDist = inf;	   

	//////////////////////////////////////

	// Render the scene here

	pixelColor = traceRay(P, w);

	//////////////////////////////////////
	 
	// Camera space z value
	float csZ = maxDist / w.z;
	
	// Pack into standard OpenGL depth buffer format to make the result compatible
	// with rasterization and post-processing.
	gl_FragDepth = (maxDist == inf) ? 1.0 : ((projectionMatrix22 * csZ + projectionMatrix23) / -csZ);
}
