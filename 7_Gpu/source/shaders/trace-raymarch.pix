#version 410 // -*- c++ -*-
#include <g3dmath.glsl>
#include <Texture/Texture.glsl>
#include "Surfel.glsl"
#include "Sphere.glsl"

// Input arguments from the C++ program
uniform mat4x3 cameraToWorldMatrix;

uniform TextureCube	environmentMap;

uniform float tanHalfFieldOfViewY;
uniform float projectionMatrix22, projectionMatrix23;

// Output to the App::m_framebuffer
out Color3 pixelColor;

const int NUM_SPHERES = 2;
Sphere spheres[NUM_SPHERES];

void fillScene()
{
	spheres[0] = Sphere(Point3(1.0f, 0.0f, -1.0f),
						0.8f,
						Material(Color3(0.5f, 0.0f, 0.0f), 0.0f, 0.0f, 0.0f));

	spheres[1] = Sphere(Point3(-1.0f, 0.0f, -1.0f),
						0.6f,
						Material(Color3(0.0f, 0.5f, 0.0f), 0.0f, 0.0f, 0.0f));
}



float opUnion(float dist1, float dist2)
{
	return min(dist1, dist2);
}

float opUnion(float dist1, Material material1, float dist2, Material material2, inout Material selectedMaterial)
{
	if (dist1 < dist2) {
		selectedMaterial = material1;
		return dist1;
	}

	selectedMaterial = material2;
	return dist2;
}

float opUnion(Point3 X, Sphere sphere1, Sphere sphere2, inout Material selectedMaterial)
{
	float dist1 = length(X - sphere1.center) - sphere1.radius;
	float dist2 = length(X - sphere2.center) - sphere2.radius;
	
	return opUnion(dist1, sphere1.material, dist2, sphere2.material, selectedMaterial);
}



float opIntersection(float dist1, float dist2)
{
	return max(dist1, dist2);
}

float opIntersection(float dist1, Material material1, float dist2, Material material2, inout Material selectedMaterial)
{
	if (dist1 > dist2) {
		selectedMaterial = material1;
		return dist1;
	}

	selectedMaterial = material2;
	return dist2;
}

float opIntersection(Point3 X, Sphere sphere1, Sphere sphere2, inout Material selectedMaterial)
{
	float dist1 = length(X - sphere1.center) - sphere1.radius;
	float dist2 = length(X - sphere2.center) - sphere2.radius;
	
	return opIntersection(dist1, sphere1.material, dist2, sphere2.material, selectedMaterial);
}



float randomObject(Point3 X, inout Material material)
{
	return opUnion(X,
				   Sphere(Point3(0.2f, 1.0f, -1.0f),
						  0.4f,
						  Material(Color3(0.5f, 0.0f, 0.5f), 0.0f, 0.0f, 0.0f)),
				   Sphere(Point3(-0.2f, 1.0f, -1.0f),
						  0.4f,
						  Material(Color3(0.0f, 0.5f, 0.5f), 0.0f, 0.0f, 0.0f)),
				   material);
}



float sceneDistance(Point3 X, inout Material closestMaterial)
{
	float sceneDist = 10000000.0f;

	for (int i = 0; i < NUM_SPHERES; i++) {
		float currDist = length(X - spheres[i].center) - spheres[i].radius;
		
		sceneDist = opUnion(sceneDist, closestMaterial, currDist, spheres[i].material, closestMaterial);
	}

	Material objectMaterial;
	float objectDist = randomObject(X, objectMaterial);

	sceneDist = opUnion(sceneDist, closestMaterial, objectDist, objectMaterial, closestMaterial);

	return sceneDist;
}



Vector3 fastNormal(Point3 X)
{
	const float e = 1e-4f;
	Material unusedMaterial;
	float d = sceneDistance(X, unusedMaterial);

	return normalize(Vector3(
			sceneDistance(X + Vector3(e, 0, 0), unusedMaterial),
			sceneDistance(X + Vector3(0, e, 0), unusedMaterial),
			sceneDistance(X + Vector3(0, 0, e), unusedMaterial)) - Vector3(d, d, d));
}



Radiance3 lambertianBrdf(Material material)
{
	return Radiance3(material.color / 3.14f);
}



Radiance3 shadeSurfel(Surfel surfel)
{
	vec3 sunRadiance = vec3(1.0f);
	vec3 sunDirection = normalize(vec3(-1.0f, -1.0f, -1.0f));

	vec3 direct = lambertianBrdf(surfel.material) * sunRadiance * max(dot(-sunDirection, surfel.normal), 0.0f);
	vec3 ambient = 0.3f * surfel.material.color;
	return direct + ambient;
}



Radiance3 traceRay(Point3 P, Vector3 w) {
	const float maxDistance   = 1e10;
	const int   maxIterations = 100;
	const float closeEnough   = 1e-2;

	float t = 0;
	Surfel closestSurfel;

	for (int i = 0; i < maxIterations; ++i) {
		float dt = sceneDistance(P + w * t, closestSurfel.material);
		t += dt;

		if (dt < closeEnough) {
			closestSurfel.position = P + w * t;
			closestSurfel.normal = fastNormal(closestSurfel.position);

			return shadeSurfel(closestSurfel);
		}
	}
	return sampleTexture(environmentMap, w).rgb;
}



void main()
{
	fillScene();

	// Generate an eye ray in camera space, and then transform to world space

	// Primary ray origin	
	Point3 P  = cameraToWorldMatrix[3];

	// Primary ray direction
	Vector3 w = Matrix3(cameraToWorldMatrix) * 
		normalize(Vector3((gl_FragCoord.xy - g3d_FragCoordExtent / 2.0) * Vector2(1, -1),
						  g3d_FragCoordExtent.y / ( -2.0 * tanHalfFieldOfViewY)));

	float maxDist = inf;	   

	//////////////////////////////////////

	// Render the scene here

	pixelColor = traceRay(P, w);

	//////////////////////////////////////
	 
	// Camera space z value
	float csZ = maxDist / w.z;
	
	// Pack into standard OpenGL depth buffer format to make the result compatible
	// with rasterization and post-processing.
	gl_FragDepth = (maxDist == inf) ? 1.0 : ((projectionMatrix22 * csZ + projectionMatrix23) / -csZ);
}
